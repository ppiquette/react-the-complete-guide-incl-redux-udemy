{"version":3,"sources":["../node_modules/babel-traverse/lib/path/inference/inferer-reference.js"],"names":["exports","_getIterator2","require","_getIterator3","_interopRequireDefault","binding","node","getTypeAnnotationBindingConstantViolations","t","_babelTypes","_interopRequireWildcard","obj","newObj","Object","default","path","types","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","_iterator","_isArray","Array","_i","_ref","violation","violations","status","functions","operator","right","left","target","name","typeofPath","typePath","typeValue","parentPath","ifStatement","getParentConditionalPath","test","paths","_path","type","inferAnnotationFromBinaryExpression","typeAnnotation","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.default = function (node) {\n  if (!this.isReferenced()) return;\n\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n};\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var violation = _ref;\n\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target = void 0;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  var typeofPath = void 0;\n  var typePath = void 0;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\nfunction getParentConditionalPath(path) {\n  var parentPath = void 0;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];"],"file":"inferer-reference.js"}