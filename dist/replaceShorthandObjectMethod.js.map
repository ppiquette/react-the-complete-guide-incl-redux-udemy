{"version":3,"sources":["../node_modules/babel-plugin-transform-regenerator/node_modules/regenerator-transform/src/replaceShorthandObjectMethod.js"],"names":["path","t","parameters","functionExpression","util"],"mappings":";;;;;;;AAAA,IAAA,CAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,IAAA,IAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAAA,4BAAA,CAAA,IAAA,EAA4C;AACzD,MAAI,CAACA,IAAI,CAAL,IAAA,IAAc,CAACC,CAAC,CAADA,UAAAA,CAAaD,IAAI,CAApC,IAAmBC,CAAnB,EAA4C;AAC1C,UAAM,IAAA,KAAA,CAAN,6EAAM,CAAN;AAFuD,GAAA,CAKzD;AACA;;;AACA,MAAI,CAACA,CAAC,CAADA,cAAAA,CAAiBD,IAAI,CAA1B,IAAKC,CAAL,EAAkC;AAChC,WAAA,IAAA;AARuD,GAAA,CAWzD;;;AACA,MAAI,CAACD,IAAI,CAAJA,IAAAA,CAAL,SAAA,EAA0B;AACxB,WAAA,IAAA;AACD;;AAED,MAAME,UAAU,GAAG,IAAI,CAAJ,IAAA,CAAA,MAAA,CAAA,GAAA,CAAqB,UAAA,KAAA,EAAiB;AACvD,WAAOD,CAAC,CAADA,SAAAA,CAAP,KAAOA,CAAP;AADF,GAAmB,CAAnB;AAIA,MAAME,kBAAkB,GAAG,CAAC,CAAD,kBAAA,CAAA,IAAA,EACnB;AADmB,EAAA,UAAA,EAEb;AACZF,EAAAA,CAAC,CAADA,SAAAA,CAAYD,IAAI,CAAJA,IAAAA,CAHa,IAGzBC,CAHyB,EAGI;AAC7BD,EAAAA,IAAI,CAAJA,IAAAA,CAJyB,SAAA,EAKzBA,IAAI,CAAJA,IAAAA,CALF,KAA2B,CAA3B;AAQAI,EAAAA,IAAI,CAAJA,mBAAAA,CAAAA,IAAAA,EACE,CAAC,CAAD,cAAA,CACEH,CAAC,CAADA,SAAAA,CAAYD,IAAI,CAAJA,IAAAA,CADd,GACEC,CADF,EAC8B;AAD9B,EAAA,kBAAA,EAEsB;AACpBD,EAAAA,IAAI,CAAJA,IAAAA,CAHF,QAAA,EAGsB;AAHtB,OAAA,CAIQ;AAJR,GADFI,EA5ByD,CAqCzD;AACA;AACA;AACA;;AACA,SAAOJ,IAAI,CAAJA,GAAAA,CAAP,OAAOA,CAAP;AACD","sourcesContent":["import * as t from \"babel-types\";\nimport * as util from \"./util\";\n\n// this function converts a shorthand object generator method into a normal\n// (non-shorthand) object property which is a generator function expression. for\n// example, this:\n//\n//  var foo = {\n//    *bar(baz) { return 5; }\n//  }\n//\n// should be replaced with:\n//\n//  var foo = {\n//    bar: function*(baz) { return 5; }\n//  }\n//\n// to do this, it clones the parameter array and the body of the object generator\n// method into a new FunctionExpression.\n//\n// this method can be passed any Function AST node path, and it will return\n// either:\n//   a) the path that was passed in (iff the path did not need to be replaced) or\n//   b) the path of the new FunctionExpression that was created as a replacement\n//     (iff the path did need to be replaced)\n//\n// In either case, though, the caller can count on the fact that the return value\n// is a Function AST node path.\n//\n// If this function is called with an AST node path that is not a Function (or with an\n// argument that isn't an AST node path), it will throw an error.\nexport default function replaceShorthandObjectMethod(path) {\n  if (!path.node || !t.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  }\n\n  // this function only replaces shorthand object methods (called ObjectMethod\n  // in Babel-speak).\n  if (!t.isObjectMethod(path.node)) {\n    return path;\n  }\n\n  // this function only replaces generators.\n  if (!path.node.generator) {\n    return path;\n  }\n\n  const parameters = path.node.params.map(function (param) {\n    return t.cloneDeep(param);\n  })\n\n  const functionExpression = t.functionExpression(\n    null, // id\n    parameters, // params\n    t.cloneDeep(path.node.body), // body\n    path.node.generator,\n    path.node.async\n  );\n\n  util.replaceWithOrRemove(path,\n    t.objectProperty(\n      t.cloneDeep(path.node.key), // key\n      functionExpression, //value\n      path.node.computed, // computed\n      false // shorthand\n    )\n  );\n\n  // path now refers to the ObjectProperty AST node path, but we want to return a\n  // Function AST node path for the function expression we created. we know that\n  // the FunctionExpression we just created is the value of the ObjectProperty,\n  // so return the \"value\" path off of this path.\n  return path.get(\"value\");\n}\n"],"file":"replaceShorthandObjectMethod.js"}