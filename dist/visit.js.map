{"version":3,"sources":["../node_modules/babel-plugin-transform-regenerator/node_modules/regenerator-transform/src/visit.js"],"names":["exports","Function","exit","node","path","state","contextId","argsId","bodyBlockPath","context","outerBody","innerBody","childPath","t","outerFnExpr","getOuterFnExpr","innerFnId","vars","didRenameArguments","renameArguments","argumentIdentifier","emitter","Emitter","wrapArgs","tryLocsList","wrapCall","util","oldDirectives","wasGeneratorFunction","funPath","getMarkedFunctionId","getMarkInfo","require","blockPath","block","assert","Array","info","markedId","markCallExp","index","markCallExpPath","funcPath","argumentsVisitor","Identifier","functionSentVisitor","MetaProperty","awaitVisitor","AwaitExpression","argument"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n\"use strict\";\n\nimport assert from \"assert\";\nimport * as t from \"babel-types\";\nimport { hoist } from \"./hoist\";\nimport { Emitter } from \"./emit\";\nimport replaceShorthandObjectMethod from \"./replaceShorthandObjectMethod\";\nimport * as util from \"./util\";\n\nexports.visitor = {\n  Function: {\n    exit: function(path, state) {\n      let node = path.node;\n\n      if (node.generator) {\n        if (node.async) {\n          // Async generator\n          if (state.opts.asyncGenerators === false) return;\n        } else {\n          // Plain generator\n          if (state.opts.generators === false) return;\n        }\n      } else if (node.async) {\n        // Async function\n        if (state.opts.async === false) return;\n      } else {\n        // Not a generator or async function.\n        return;\n      }\n\n      // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n      path = replaceShorthandObjectMethod(path);\n      node = path.node;\n\n      let contextId = path.scope.generateUidIdentifier(\"context\");\n      let argsId = path.scope.generateUidIdentifier(\"args\");\n\n      path.ensureBlock();\n      let bodyBlockPath = path.get(\"body\");\n\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor);\n      }\n\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId\n      });\n\n      let outerBody = [];\n      let innerBody = [];\n\n      bodyBlockPath.get(\"body\").forEach(function(childPath) {\n        let node = childPath.node;\n        if (t.isExpressionStatement(node) &&\n            t.isStringLiteral(node.expression)) {\n          // Babylon represents directives like \"use strict\" as elements\n          // of a bodyBlockPath.node.directives array, but they could just\n          // as easily be represented (by other parsers) as traditional\n          // string-literal-valued expression statements, so we need to\n          // handle that here. (#248)\n          outerBody.push(node);\n        } else if (node && node._blockHoist != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n\n      if (outerBody.length > 0) {\n        // Only replace the inner body if we actually hoisted any statements\n        // to the outer body.\n        bodyBlockPath.node.body = innerBody;\n      }\n\n      let outerFnExpr = getOuterFnExpr(path);\n      // Note that getOuterFnExpr has the side-effect of ensuring that the\n      // function has a name (so node.id will always be an Identifier), even\n      // if a temporary name has to be synthesized.\n      t.assertIdentifier(node.id);\n      let innerFnId = t.identifier(node.id.name + \"$\");\n\n      // Turn all declarations into vars, and replace the original\n      // declarations with equivalent assignment expressions.\n      let vars = hoist(path);\n\n      let didRenameArguments = renameArguments(path, argsId);\n      if (didRenameArguments) {\n        vars = vars || t.variableDeclaration(\"var\", []);\n        const argumentIdentifier = t.identifier(\"arguments\");\n        // we need to do this as otherwise arguments in arrow functions gets hoisted\n        argumentIdentifier._shadowedFunctionLiteral = path;\n        vars.declarations.push(t.variableDeclarator(\n          argsId, argumentIdentifier\n        ));\n      }\n\n      let emitter = new Emitter(contextId);\n      emitter.explode(path.get(\"body\"));\n\n      if (vars && vars.declarations.length > 0) {\n        outerBody.push(vars);\n      }\n\n      let wrapArgs = [\n        emitter.getContextFunction(innerFnId),\n        // Async functions that are not generators don't care about the\n        // outer function because they don't need it to be marked and don't\n        // inherit from its .prototype.\n        node.generator ? outerFnExpr : t.nullLiteral(),\n        t.thisExpression()\n      ];\n\n      let tryLocsList = emitter.getTryLocsList();\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      }\n\n      let wrapCall = t.callExpression(\n        util.runtimeProperty(node.async ? \"async\" : \"wrap\"),\n        wrapArgs\n      );\n\n      outerBody.push(t.returnStatement(wrapCall));\n      node.body = t.blockStatement(outerBody);\n\n      const oldDirectives = bodyBlockPath.node.directives;\n      if (oldDirectives) {\n        // Babylon represents directives like \"use strict\" as elements of\n        // a bodyBlockPath.node.directives array. (#248)\n        node.body.directives = oldDirectives;\n      }\n\n      let wasGeneratorFunction = node.generator;\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n\n      if (node.async) {\n        node.async = false;\n      }\n\n      if (wasGeneratorFunction && t.isExpression(node)) {\n        util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]))\n        path.addComment(\"leading\", \"#__PURE__\");\n      }\n\n      // Generators are processed in 'exit' handlers so that regenerator only has to run on\n      // an ES5 AST, but that means traversal will not pick up newly inserted references\n      // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n      path.requeue();\n    }\n  }\n};\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  let node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n      t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return node.id;\n}\n\nconst getMarkInfo = require(\"private\").makeAccessor();\n\nfunction getMarkedFunctionId(funPath) {\n  const node = funPath.node;\n  t.assertIdentifier(node.id);\n\n  const blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  const block = blockPath.node;\n  assert.ok(Array.isArray(block.body));\n\n  const info = getMarkInfo(block);\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  assert.strictEqual(info.declPath.node, info.decl);\n\n  // Get a new unique identifier for our marked variable.\n  const markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  const markCallExp = t.callExpression(\n    util.runtimeProperty(\"mark\"),\n    [node.id]\n  );\n\n  const index = info.decl.declarations.push(\n    t.variableDeclarator(markedId, markCallExp)\n  ) - 1;\n\n  const markCallExpPath =\n    info.declPath.get(\"declarations.\" + index + \".init\");\n\n  assert.strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n\n  return markedId;\n}\n\nfunction renameArguments(funcPath, argsId) {\n  let state = {\n    didRenameArguments: false,\n    argsId: argsId\n  };\n\n  funcPath.traverse(argumentsVisitor, state);\n\n  // If the traversal replaced any arguments references, then we need to\n  // alias the outer function's arguments binding (be it the implicit\n  // arguments object or some other parameter or variable) to the variable\n  // named by argsId.\n  return state.didRenameArguments;\n}\n\nlet argumentsVisitor = {\n  \"FunctionExpression|FunctionDeclaration\": function(path) {\n    path.skip();\n  },\n\n  Identifier: function(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.argsId);\n      state.didRenameArguments = true;\n    }\n  }\n};\n\nlet functionSentVisitor = {\n  MetaProperty(path) {\n    let { node } = path;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      util.replaceWithOrRemove(path, t.memberExpression(this.context, t.identifier(\"_sent\")));\n    }\n  }\n};\n\nlet awaitVisitor = {\n  Function: function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function(path) {\n    // Convert await expressions to yield expressions.\n    let argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    util.replaceWithOrRemove(path, t.yieldExpression(\n      t.callExpression(\n        util.runtimeProperty(\"awrap\"),\n        [argument]\n      ),\n      false\n    ));\n  }\n};\n"],"file":"visit.js"}