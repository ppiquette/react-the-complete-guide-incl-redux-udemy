{"version":3,"sources":["../node_modules/babel-plugin-transform-regenerator/node_modules/regenerator-transform/src/meta.js"],"names":["m","require","hasOwn","Object","t","result","Array","child","assert","predicate","keys","node","i","key","check","meta","onlyChildren","opaqueTypes","FunctionExpression","ArrowFunctionExpression","sideEffectTypes","CallExpression","ForInStatement","UnaryExpression","BinaryExpression","AssignmentExpression","UpdateExpression","NewExpression","leapTypes","YieldExpression","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","exports","makePredicate"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport assert from \"assert\";\nlet m = require(\"private\").makeAccessor();\nimport * as t from \"babel-types\";\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    let result = false;\n\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        assert.strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n\n    let keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    t.assertNode(node);\n\n    let meta = m(node);\n    if (hasOwn.call(meta, propertyName))\n      return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type))\n      return meta[propertyName] = false;\n\n    if (hasOwn.call(knownTypes, node.type))\n      return meta[propertyName] = true;\n\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n\n  return predicate;\n}\n\nlet opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nlet sideEffectTypes = {\n  CallExpression: true, // Anything could happen!\n  ForInStatement: true, // Modifies the key variable.\n  UnaryExpression: true, // Think delete.\n  BinaryExpression: true, // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true, // Side-effecting by definition.\n  UpdateExpression: true, // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nlet leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (let type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);\n"],"file":"meta.js"}