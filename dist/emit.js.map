{"version":3,"sources":["../node_modules/babel-plugin-transform-regenerator/node_modules/regenerator-transform/src/emit.js"],"names":["hasOwn","Object","assert","t","loc","leap","Ep","Emitter","exports","index","node","computed","valuePath","catchCall","test","negatedTest","id","self","cases","alreadyEnded","current","lastLocValue","thisLocValue","tryEntry","ce","fe","locs","path","getDeclError","JSON","stmt","labelId","meta","after","before","first","head","update","keyIterNextFn","util","keyInfoTmpVar","type","target","disc","defaultLoc","condition","caseLocs","i","c","discriminant","casePath","elseLoc","value","handler","catchLoc","catchEntry","finallyLoc","finallyEntry","bodyPath","safeParam","catchParamName","name","catchParamVisitor","Identifier","state","Scope","isValidCompletion","record","abruptArgs","expr","finish","hasLeapingChildren","result","tempVar","explodeViaTempVar","calleePath","argsPath","newArgs","hasLeapingArgs","argPath","newObject","newProperty","newCallee","propPath","lastIndex","exprPath","left","arg"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport assert from \"assert\";\nimport * as t from \"babel-types\";\nimport * as leap from \"./leap\";\nimport * as meta from \"./meta\";\nimport * as util from \"./util\";\n\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  assert.ok(this instanceof Emitter);\n  t.assertIdentifier(contextId);\n\n  // Used to generate unique temporary names.\n  this.nextTempId = 0;\n\n  // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n  this.contextId = contextId;\n\n  // An append-only list of Statements that grows each time this.emit is\n  // called.\n  this.listing = [];\n\n  // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n  this.marked = [true];\n\n  // The last location will be marked when this.getDispatchLoop is\n  // called.\n  this.finalLoc = loc();\n\n  // A list of all leap.TryEntry statements emitted.\n  this.tryEntries = [];\n\n  // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n  this.leapManager = new leap.LeapManager(this);\n}\n\nlet Ep = Emitter.prototype;\nexports.Emitter = Emitter;\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\nfunction loc() {\n  return t.numericLiteral(-1);\n}\n\n// Sets the exact value of the given location to the offset of the next\n// Statement emitted.\nEp.mark = function(loc) {\n  t.assertLiteral(loc);\n  let index = this.listing.length;\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    assert.strictEqual(loc.value, index);\n  }\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function(node) {\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n};\n\n// Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\nEp.emitAssign = function(lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n};\n\n// Shorthand for an assignment statement.\nEp.assign = function(lhs, rhs) {\n  return t.expressionStatement(\n    t.assignmentExpression(\"=\", lhs, rhs));\n};\n\n// Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\nEp.contextProperty = function(name, computed) {\n  return t.memberExpression(\n    this.contextId,\n    computed ? t.stringLiteral(name) : t.identifier(name),\n    !!computed\n  );\n};\n\n// Shorthand for setting context.rval and jumping to `context.stop()`.\nEp.stop = function(rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function(valuePath) {\n  t.assertExpression(valuePath.value);\n\n  this.emitAssign(\n    this.contextProperty(\"rval\"),\n    this.explodeExpression(valuePath)\n  );\n};\n\nEp.clearPendingException = function(tryLoc, assignee) {\n  t.assertLiteral(tryLoc);\n\n  let catchCall = t.callExpression(\n    this.contextProperty(\"catch\", true),\n    [tryLoc]\n  );\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n};\n\n// Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\nEp.jump = function(toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(t.breakStatement());\n};\n\n// Conditional jump.\nEp.jumpIf = function(test, toLoc) {\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  this.emit(t.ifStatement(\n    test,\n    t.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      t.breakStatement()\n    ])\n  ));\n};\n\n// Conditional jump, with the condition negated.\nEp.jumpIfNot = function(test, toLoc) {\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  let negatedTest;\n  if (t.isUnaryExpression(test) &&\n      test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(\n    negatedTest,\n    t.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      t.breakStatement()\n    ])\n  ));\n};\n\n// Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\nEp.makeTempVar = function() {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function(id) {\n  return t.functionExpression(\n    id || null/*Anonymous*/,\n    [this.contextId],\n    t.blockStatement([this.getDispatchLoop()]),\n    false, // Not a generator anymore!\n    false // Nor an expression.\n  );\n};\n\n// Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\nEp.getDispatchLoop = function() {\n  let self = this;\n  let cases = [];\n  let current;\n\n  // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n  let alreadyEnded = false;\n\n  self.listing.forEach(function(stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(\n        t.numericLiteral(i),\n        current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt))\n        alreadyEnded = true;\n    }\n  });\n\n  // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n  this.finalLoc.value = this.listing.length;\n\n  cases.push(\n    t.switchCase(this.finalLoc, [\n      // Intentionally fall through to the \"end\" case...\n    ]),\n\n    // So that the runtime can jump to the final location without having\n    // to know its offset, we provide the \"end\" case as a synonym.\n    t.switchCase(t.stringLiteral(\"end\"), [\n      // This will check/clear both context.thrown and context.rval.\n      t.returnStatement(\n        t.callExpression(this.contextProperty(\"stop\"), [])\n      )\n    ])\n  );\n\n  return t.whileStatement(\n    t.numericLiteral(1),\n    t.switchStatement(\n      t.assignmentExpression(\n        \"=\",\n        this.contextProperty(\"prev\"),\n        this.contextProperty(\"next\")\n      ),\n      cases\n    )\n  );\n};\n\nEp.getTryLocsList = function() {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  let lastLocValue = 0;\n\n  return t.arrayExpression(\n    this.tryEntries.map(function(tryEntry) {\n      let thisLocValue = tryEntry.firstLoc.value;\n      assert.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n      lastLocValue = thisLocValue;\n\n      let ce = tryEntry.catchEntry;\n      let fe = tryEntry.finallyEntry;\n\n      let locs = [\n        tryEntry.firstLoc,\n        // The null here makes a hole in the array.\n        ce ? ce.firstLoc : null\n      ];\n\n      if (fe) {\n        locs[2] = fe.firstLoc;\n        locs[3] = fe.afterLoc;\n      }\n\n      return t.arrayExpression(locs);\n    })\n  );\n};\n\n// All side effects must be realized in order.\n\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n\n// No destructive modification of AST nodes.\n\nEp.explode = function(path, ignoreResult) {\n  let node = path.node;\n  let self = this;\n\n  t.assertNode(node);\n\n  if (t.isDeclaration(node))\n    throw getDeclError(node);\n\n  if (t.isStatement(node))\n    return self.explodeStatement(path);\n\n  if (t.isExpression(node))\n    return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n  case \"Program\":\n    return path.get(\"body\").map(\n      self.explodeStatement,\n      self\n    );\n\n  case \"VariableDeclarator\":\n    throw getDeclError(node);\n\n  // These node types should be handled by their parent nodes\n  // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n  case \"Property\":\n  case \"SwitchCase\":\n  case \"CatchClause\":\n    throw new Error(\n      node.type + \" nodes should be handled by their parents\");\n\n  default:\n    throw new Error(\n      \"unknown Node of type \" +\n        JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\n    \"all declarations should have been transformed into \" +\n    \"assignments before the Exploder began its work: \" +\n    JSON.stringify(node));\n}\n\nEp.explodeStatement = function(path, labelId) {\n  let stmt = path.node;\n  let self = this;\n  let before, after, head;\n\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  }\n\n  // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n  case \"ExpressionStatement\":\n    self.explodeExpression(path.get(\"expression\"), true);\n    break;\n\n  case \"LabeledStatement\":\n    after = loc();\n\n    // Did you know you can break from any labeled block statement or\n    // control structure? Well, you can! Note: when a labeled loop is\n    // encountered, the leap.LabeledEntry created here will immediately\n    // enclose a leap.LoopEntry on the leap manager's stack, and both\n    // entries will have the same label. Though this works just fine, it\n    // may seem a bit redundant. In theory, we could check here to\n    // determine if stmt knows how to handle its own label; for example,\n    // stmt happens to be a WhileStatement and so we know it's going to\n    // establish its own LoopEntry when we explode it (below). Then this\n    // LabeledEntry would be unnecessary. Alternatively, we might be\n    // tempted not to pass stmt.label down into self.explodeStatement,\n    // because we've handled the label here, but that's a mistake because\n    // labeled loops may contain labeled continue statements, which is not\n    // something we can handle in this generic case. All in all, I think a\n    // little redundancy greatly simplifies the logic of this case, since\n    // it's clear that we handle all possible LabeledStatements correctly\n    // here, regardless of whether they interact with the leap manager\n    // themselves. Also remember that labels and break/continue-to-label\n    // statements are rare, and all of this logic happens at transform\n    // time, so it has no additional runtime cost.\n    self.leapManager.withEntry(\n      new leap.LabeledEntry(after, stmt.label),\n      function() {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      }\n    );\n\n    self.mark(after);\n\n    break;\n\n  case \"WhileStatement\":\n    before = loc();\n    after = loc();\n\n    self.mark(before);\n    self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, before, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n    self.jump(before);\n    self.mark(after);\n\n    break;\n\n  case \"DoWhileStatement\":\n    let first = loc();\n    let test = loc();\n    after = loc();\n\n    self.mark(first);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, test, labelId),\n      function() { self.explode(path.get(\"body\")); }\n    );\n    self.mark(test);\n    self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n    self.mark(after);\n\n    break;\n\n  case \"ForStatement\":\n    head = loc();\n    let update = loc();\n    after = loc();\n\n    if (stmt.init) {\n      // We pass true here to indicate that if stmt.init is an expression\n      // then we do not care about its result.\n      self.explode(path.get(\"init\"), true);\n    }\n\n    self.mark(head);\n\n    if (stmt.test) {\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    } else {\n      // No test means continue unconditionally.\n    }\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, update, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.mark(update);\n\n    if (stmt.update) {\n      // We pass true here to indicate that if stmt.update is an\n      // expression then we do not care about its result.\n      self.explode(path.get(\"update\"), true);\n    }\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"TypeCastExpression\":\n    return self.explodeExpression(path.get(\"expression\"));\n\n  case \"ForInStatement\":\n    head = loc();\n    after = loc();\n\n    let keyIterNextFn = self.makeTempVar();\n    self.emitAssign(\n      keyIterNextFn,\n      t.callExpression(\n        util.runtimeProperty(\"keys\"),\n        [self.explodeExpression(path.get(\"right\"))]\n      )\n    );\n\n    self.mark(head);\n\n    let keyInfoTmpVar = self.makeTempVar();\n    self.jumpIf(\n      t.memberExpression(\n        t.assignmentExpression(\n          \"=\",\n          keyInfoTmpVar,\n          t.callExpression(keyIterNextFn, [])\n        ),\n        t.identifier(\"done\"),\n        false\n      ),\n      after\n    );\n\n    self.emitAssign(\n      stmt.left,\n      t.memberExpression(\n        keyInfoTmpVar,\n        t.identifier(\"value\"),\n        false\n      )\n    );\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, head, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"BreakStatement\":\n    self.emitAbruptCompletion({\n      type: \"break\",\n      target: self.leapManager.getBreakLoc(stmt.label)\n    });\n\n    break;\n\n  case \"ContinueStatement\":\n    self.emitAbruptCompletion({\n      type: \"continue\",\n      target: self.leapManager.getContinueLoc(stmt.label)\n    });\n\n    break;\n\n  case \"SwitchStatement\":\n    // Always save the discriminant into a temporary variable in case the\n    // test expressions overwrite values like context.sent.\n    let disc = self.emitAssign(\n      self.makeTempVar(),\n      self.explodeExpression(path.get(\"discriminant\"))\n    );\n\n    after = loc();\n    let defaultLoc = loc();\n    let condition = defaultLoc;\n    let caseLocs = [];\n\n    // If there are no cases, .cases might be undefined.\n    let cases = stmt.cases || [];\n\n    for (let i = cases.length - 1; i >= 0; --i) {\n      let c = cases[i];\n      t.assertSwitchCase(c);\n\n      if (c.test) {\n        condition = t.conditionalExpression(\n          t.binaryExpression(\"===\", disc, c.test),\n          caseLocs[i] = loc(),\n          condition\n        );\n      } else {\n        caseLocs[i] = defaultLoc;\n      }\n    }\n\n    let discriminant = path.get(\"discriminant\");\n    util.replaceWithOrRemove(discriminant, condition);\n    self.jump(self.explodeExpression(discriminant));\n\n    self.leapManager.withEntry(\n      new leap.SwitchEntry(after),\n      function() {\n        path.get(\"cases\").forEach(function(casePath) {\n          let i = casePath.key;\n          self.mark(caseLocs[i]);\n\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      }\n    );\n\n    self.mark(after);\n    if (defaultLoc.value === -1) {\n      self.mark(defaultLoc);\n      assert.strictEqual(after.value, defaultLoc.value);\n    }\n\n    break;\n\n  case \"IfStatement\":\n    let elseLoc = stmt.alternate && loc();\n    after = loc();\n\n    self.jumpIfNot(\n      self.explodeExpression(path.get(\"test\")),\n      elseLoc || after\n    );\n\n    self.explodeStatement(path.get(\"consequent\"));\n\n    if (elseLoc) {\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeStatement(path.get(\"alternate\"));\n    }\n\n    self.mark(after);\n\n    break;\n\n  case \"ReturnStatement\":\n    self.emitAbruptCompletion({\n      type: \"return\",\n      value: self.explodeExpression(path.get(\"argument\"))\n    });\n\n    break;\n\n  case \"WithStatement\":\n    throw new Error(\"WithStatement not supported in generator functions.\");\n\n  case \"TryStatement\":\n    after = loc();\n\n    let handler = stmt.handler;\n\n    let catchLoc = handler && loc();\n    let catchEntry = catchLoc && new leap.CatchEntry(\n      catchLoc,\n      handler.param\n    );\n\n    let finallyLoc = stmt.finalizer && loc();\n    let finallyEntry = finallyLoc &&\n      new leap.FinallyEntry(finallyLoc, after);\n\n    let tryEntry = new leap.TryEntry(\n      self.getUnmarkedCurrentLoc(),\n      catchEntry,\n      finallyEntry\n    );\n\n    self.tryEntries.push(tryEntry);\n    self.updateContextPrevLoc(tryEntry.firstLoc);\n\n    self.leapManager.withEntry(tryEntry, function() {\n      self.explodeStatement(path.get(\"block\"));\n\n      if (catchLoc) {\n        if (finallyLoc) {\n          // If we have both a catch block and a finally block, then\n          // because we emit the catch block first, we need to jump over\n          // it to the finally block.\n          self.jump(finallyLoc);\n\n        } else {\n          // If there is no finally block, then we need to jump over the\n          // catch block to the fall-through location.\n          self.jump(after);\n        }\n\n        self.updateContextPrevLoc(self.mark(catchLoc));\n\n        let bodyPath = path.get(\"handler.body\");\n        let safeParam = self.makeTempVar();\n        self.clearPendingException(tryEntry.firstLoc, safeParam);\n\n        bodyPath.traverse(catchParamVisitor, {\n          safeParam: safeParam,\n          catchParamName: handler.param.name\n        });\n\n        self.leapManager.withEntry(catchEntry, function() {\n          self.explodeStatement(bodyPath);\n        });\n      }\n\n      if (finallyLoc) {\n        self.updateContextPrevLoc(self.mark(finallyLoc));\n\n        self.leapManager.withEntry(finallyEntry, function() {\n          self.explodeStatement(path.get(\"finalizer\"));\n        });\n\n        self.emit(t.returnStatement(t.callExpression(\n          self.contextProperty(\"finish\"),\n          [finallyEntry.firstLoc]\n        )));\n      }\n    });\n\n    self.mark(after);\n\n    break;\n\n  case \"ThrowStatement\":\n    self.emit(t.throwStatement(\n      self.explodeExpression(path.get(\"argument\"))\n    ));\n\n    break;\n\n  default:\n    throw new Error(\n      \"unknown Statement of type \" +\n        JSON.stringify(stmt.type));\n  }\n};\n\nlet catchParamVisitor = {\n  Identifier: function(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.safeParam);\n    }\n  },\n\n  Scope: function(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function(record) {\n  if (!isValidCompletion(record)) {\n    assert.ok(\n      false,\n      \"invalid completion record: \" +\n        JSON.stringify(record)\n    );\n  }\n\n  assert.notStrictEqual(\n    record.type, \"normal\",\n    \"normal completions are not abrupt\"\n  );\n\n  let abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" ||\n      record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = record.target;\n  } else if (record.type === \"return\" ||\n             record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = record.value;\n    }\n  }\n\n  this.emit(\n    t.returnStatement(\n      t.callExpression(\n        this.contextProperty(\"abrupt\"),\n        abruptArgs\n      )\n    )\n  );\n};\n\nfunction isValidCompletion(record) {\n  let type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" ||\n      type === \"continue\") {\n    return !hasOwn.call(record, \"value\")\n        && t.isLiteral(record.target);\n  }\n\n  if (type === \"return\" ||\n      type === \"throw\") {\n    return hasOwn.call(record, \"value\")\n        && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n}\n\n\n// Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\nEp.getUnmarkedCurrentLoc = function() {\n  return t.numericLiteral(this.listing.length);\n};\n\n// The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\nEp.updateContextPrevLoc = function(loc) {\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      assert.strictEqual(loc.value, this.listing.length);\n    }\n\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  }\n\n  // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\nEp.explodeExpression = function(path, ignoreResult) {\n  let expr = path.node;\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  let self = this;\n  let result; // Used optionally by several cases below.\n  let after;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n    if (ignoreResult) {\n      self.emit(expr);\n    } else {\n      return expr;\n    }\n  }\n\n  // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  }\n\n  // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n  let hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n\n  // In order to save the rest of explodeExpression from a combinatorial\n  // trainwreck of special cases, explodeViaTempVar is responsible for\n  // deciding when a subexpression needs to be \"exploded,\" which is my\n  // very technical term for emitting the subexpression as an assignment\n  // to a temporary variable and the substituting the temporary variable\n  // for the original subexpression. Think of exploded view diagrams, not\n  // Michael Bay movies. The point of exploding subexpressions is to\n  // control the precise order in which the generated code realizes the\n  // side effects of those subexpressions.\n  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {\n    assert.ok(\n      !ignoreChildResult || !tempVar,\n      \"Ignoring the result of a child expression but forcing it to \" +\n        \"be assigned to a temporary variable?\"\n    );\n\n    let result = self.explodeExpression(childPath, ignoreChildResult);\n\n    if (ignoreChildResult) {\n      // Side effects already emitted above.\n\n    } else if (tempVar || (hasLeapingChildren &&\n                           !t.isLiteral(result))) {\n      // If tempVar was provided, then the result will always be assigned\n      // to it, even if the result does not otherwise need to be assigned\n      // to a temporary variable.  When no tempVar is provided, we have\n      // the flexibility to decide whether a temporary variable is really\n      // necessary.  Unfortunately, in general, a temporary variable is\n      // required whenever any child contains a yield expression, since it\n      // is difficult to prove (at all, let alone efficiently) whether\n      // this result would evaluate to the same value before and after the\n      // yield (see #206).  One narrow case where we can prove it doesn't\n      // matter (and thus we do not need a temporary variable) is when the\n      // result in question is a Literal value.\n      result = self.emitAssign(\n        tempVar || self.makeTempVar(),\n        result\n      );\n    }\n    return result;\n  }\n\n  // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n  case \"MemberExpression\":\n    return finish(t.memberExpression(\n      self.explodeExpression(path.get(\"object\")),\n      expr.computed\n        ? explodeViaTempVar(null, path.get(\"property\"))\n        : expr.property,\n      expr.computed\n    ));\n\n  case \"CallExpression\":\n    let calleePath = path.get(\"callee\");\n    let argsPath = path.get(\"arguments\");\n\n    let newCallee;\n    let newArgs = [];\n\n    let hasLeapingArgs = false;\n    argsPath.forEach(function(argPath) {\n      hasLeapingArgs = hasLeapingArgs ||\n        meta.containsLeap(argPath.node);\n    });\n\n    if (t.isMemberExpression(calleePath.node)) {\n      if (hasLeapingArgs) {\n        // If the arguments of the CallExpression contained any yield\n        // expressions, then we need to be sure to evaluate the callee\n        // before evaluating the arguments, but if the callee was a member\n        // expression, then we must be careful that the object of the\n        // member expression still gets bound to `this` for the call.\n\n        let newObject = explodeViaTempVar(\n          // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(),\n          calleePath.get(\"object\")\n        );\n\n        let newProperty = calleePath.node.computed\n          ? explodeViaTempVar(null, calleePath.get(\"property\"))\n          : calleePath.node.property;\n\n        newArgs.unshift(newObject);\n\n        newCallee = t.memberExpression(\n          t.memberExpression(\n            newObject,\n            newProperty,\n            calleePath.node.computed\n          ),\n          t.identifier(\"call\"),\n          false\n        );\n\n      } else {\n        newCallee = self.explodeExpression(calleePath);\n      }\n\n    } else {\n      newCallee = explodeViaTempVar(null, calleePath);\n\n      if (t.isMemberExpression(newCallee)) {\n        // If the callee was not previously a MemberExpression, then the\n        // CallExpression was \"unqualified,\" meaning its `this` object\n        // should be the global object. If the exploded expression has\n        // become a MemberExpression (e.g. a context property, probably a\n        // temporary variable), then we need to force it to be unqualified\n        // by using the (0, object.property)(...) trick; otherwise, it\n        // will receive the object of the MemberExpression as its `this`\n        // object.\n        newCallee = t.sequenceExpression([\n          t.numericLiteral(0),\n          newCallee\n        ]);\n      }\n    }\n\n    argsPath.forEach(function(argPath) {\n      newArgs.push(explodeViaTempVar(null, argPath));\n    });\n\n    return finish(t.callExpression(\n      newCallee,\n      newArgs\n    ));\n\n  case \"NewExpression\":\n    return finish(t.newExpression(\n      explodeViaTempVar(null, path.get(\"callee\")),\n      path.get(\"arguments\").map(function(argPath) {\n        return explodeViaTempVar(null, argPath);\n      })\n    ));\n\n  case \"ObjectExpression\":\n    return finish(t.objectExpression(\n      path.get(\"properties\").map(function(propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(\n            propPath.node.key,\n            explodeViaTempVar(null, propPath.get(\"value\")),\n            propPath.node.computed\n          );\n        } else {\n          return propPath.node;\n        }\n      })\n    ));\n\n  case \"ArrayExpression\":\n    return finish(t.arrayExpression(\n      path.get(\"elements\").map(function(elemPath) {\n        return explodeViaTempVar(null, elemPath);\n      })\n    ));\n\n  case \"SequenceExpression\":\n    let lastIndex = expr.expressions.length - 1;\n\n    path.get(\"expressions\").forEach(function(exprPath) {\n      if (exprPath.key === lastIndex) {\n        result = self.explodeExpression(exprPath, ignoreResult);\n      } else {\n        self.explodeExpression(exprPath, true);\n      }\n    });\n\n    return result;\n\n  case \"LogicalExpression\":\n    after = loc();\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    let left = explodeViaTempVar(result, path.get(\"left\"));\n\n    if (expr.operator === \"&&\") {\n      self.jumpIfNot(left, after);\n    } else {\n      assert.strictEqual(expr.operator, \"||\");\n      self.jumpIf(left, after);\n    }\n\n    explodeViaTempVar(result, path.get(\"right\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"ConditionalExpression\":\n    let elseLoc = loc();\n    after = loc();\n    let test = self.explodeExpression(path.get(\"test\"));\n\n    self.jumpIfNot(test, elseLoc);\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    explodeViaTempVar(result, path.get(\"consequent\"), ignoreResult);\n    self.jump(after);\n\n    self.mark(elseLoc);\n    explodeViaTempVar(result, path.get(\"alternate\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"UnaryExpression\":\n    return finish(t.unaryExpression(\n      expr.operator,\n      // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")),\n      !!expr.prefix\n    ));\n\n  case \"BinaryExpression\":\n    return finish(t.binaryExpression(\n      expr.operator,\n      explodeViaTempVar(null, path.get(\"left\")),\n      explodeViaTempVar(null, path.get(\"right\"))\n    ));\n\n  case \"AssignmentExpression\":\n    return finish(t.assignmentExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"left\")),\n      self.explodeExpression(path.get(\"right\"))\n    ));\n\n  case \"UpdateExpression\":\n    return finish(t.updateExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"argument\")),\n      expr.prefix\n    ));\n\n  case \"YieldExpression\":\n    after = loc();\n    let arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n    if (arg && expr.delegate) {\n      let result = self.makeTempVar();\n\n      self.emit(t.returnStatement(t.callExpression(\n        self.contextProperty(\"delegateYield\"), [\n          arg,\n          t.stringLiteral(result.property.name),\n          after\n        ]\n      )));\n\n      self.mark(after);\n\n      return result;\n    }\n\n    self.emitAssign(self.contextProperty(\"next\"), after);\n    self.emit(t.returnStatement(arg || null));\n    self.mark(after);\n\n    return self.contextProperty(\"sent\");\n\n  default:\n    throw new Error(\n      \"unknown Expression of type \" +\n        JSON.stringify(expr.type));\n  }\n};\n"],"file":"emit.js"}