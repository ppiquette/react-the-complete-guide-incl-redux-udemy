{"version":3,"sources":["../node_modules/babel-plugin-transform-regenerator/node_modules/regenerator-transform/src/hoist.js"],"names":["hasOwn","Object","exports","t","funPath","vars","exprs","vdec","dec","VariableDeclaration","exit","expr","varDeclToExpr","path","util","ForStatement","init","ForXStatement","left","FunctionDeclaration","node","assignment","FunctionExpression","paramNames","param","paramPath","declarations"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport * as t from \"babel-types\";\nimport * as util from \"./util\";\nlet hasOwn = Object.prototype.hasOwnProperty;\n\n// The hoist function takes a FunctionExpression or FunctionDeclaration\n// and replaces any Declaration nodes in its body with assignments, then\n// returns a VariableDeclaration containing just the names of the removed\n// declarations.\nexports.hoist = function(funPath) {\n  t.assertFunction(funPath.node);\n\n  let vars = {};\n\n  function varDeclToExpr(vdec, includeIdentifiers) {\n    t.assertVariableDeclaration(vdec);\n    // TODO assert.equal(vdec.kind, \"var\");\n    let exprs = [];\n\n    vdec.declarations.forEach(function(dec) {\n      // Note: We duplicate 'dec.id' here to ensure that the variable declaration IDs don't\n      // have the same 'loc' value, since that can make sourcemaps and retainLines behave poorly.\n      vars[dec.id.name] = t.identifier(dec.id.name);\n\n      if (dec.init) {\n        exprs.push(t.assignmentExpression(\n          \"=\", dec.id, dec.init\n        ));\n      } else if (includeIdentifiers) {\n        exprs.push(dec.id);\n      }\n    });\n\n    if (exprs.length === 0)\n      return null;\n\n    if (exprs.length === 1)\n      return exprs[0];\n\n    return t.sequenceExpression(exprs);\n  }\n\n  funPath.get(\"body\").traverse({\n    VariableDeclaration: {\n      exit: function(path) {\n        let expr = varDeclToExpr(path.node, false);\n        if (expr === null) {\n          path.remove();\n        } else {\n          // We don't need to traverse this expression any further because\n          // there can't be any new declarations inside an expression.\n          util.replaceWithOrRemove(path, t.expressionStatement(expr));\n        }\n\n        // Since the original node has been either removed or replaced,\n        // avoid traversing it any further.\n        path.skip();\n      }\n    },\n\n    ForStatement: function(path) {\n      let init = path.node.init;\n      if (t.isVariableDeclaration(init)) {\n        util.replaceWithOrRemove(path.get(\"init\"), varDeclToExpr(init, false));\n      }\n    },\n\n    ForXStatement: function(path) {\n      let left = path.get(\"left\");\n      if (left.isVariableDeclaration()) {\n        util.replaceWithOrRemove(left, varDeclToExpr(left.node, true));\n      }\n    },\n\n    FunctionDeclaration: function(path) {\n      let node = path.node;\n      vars[node.id.name] = node.id;\n\n      let assignment = t.expressionStatement(\n        t.assignmentExpression(\n          \"=\",\n          node.id,\n          t.functionExpression(\n            node.id,\n            node.params,\n            node.body,\n            node.generator,\n            node.expression\n          )\n        )\n      );\n\n      if (path.parentPath.isBlockStatement()) {\n        // Insert the assignment form before the first statement in the\n        // enclosing block.\n        path.parentPath.unshiftContainer(\"body\", assignment);\n\n        // Remove the function declaration now that we've inserted the\n        // equivalent assignment form at the beginning of the block.\n        path.remove();\n      } else {\n        // If the parent node is not a block statement, then we can just\n        // replace the declaration with the equivalent assignment form\n        // without worrying about hoisting it.\n        util.replaceWithOrRemove(path, assignment);\n      }\n\n      // Don't hoist variables out of inner functions.\n      path.skip();\n    },\n\n    FunctionExpression: function(path) {\n      // Don't descend into nested function expressions.\n      path.skip();\n    }\n  });\n\n  let paramNames = {};\n  funPath.get(\"params\").forEach(function(paramPath) {\n    let param = paramPath.node;\n    if (t.isIdentifier(param)) {\n      paramNames[param.name] = param;\n    } else {\n      // Variables declared by destructuring parameter patterns will be\n      // harmlessly re-declared.\n    }\n  });\n\n  let declarations = [];\n\n  Object.keys(vars).forEach(function(name) {\n    if (!hasOwn.call(paramNames, name)) {\n      declarations.push(t.variableDeclarator(vars[name], null));\n    }\n  });\n\n  if (declarations.length === 0) {\n    return null; // Be sure to handle this case!\n  }\n\n  return t.variableDeclaration(\"var\", declarations);\n};\n"],"file":"hoist.js"}